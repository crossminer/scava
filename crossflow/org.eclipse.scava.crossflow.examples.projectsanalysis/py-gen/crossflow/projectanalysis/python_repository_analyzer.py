import multiprocessing
import time

from crossflow.runtime import FailedJob, Task
from crossflow.projectanalysis.projects_analysis_tasks import ProjectsAnalysisTasks

from crossflow.projectanalysis.python_repository_analysis_result import PythonRepositoryAnalysisResult


class PythonRepositoryAnalyzerBase(Task):
    """NOTE: Auto-generated by Task2BaseClass on 2019-12-18T13:41:54.162Z    
    Do not edit this class manually
    """
    
    task_enum: ProjectsAnalysisTasks = ProjectsAnalysisTasks.PYTHON_REPOSITORY_ANALYZER

    def __init__(self):
        super().__init__()
        
        # Streams
        self.repositoryAnalysisResults = None
        self._has_sent_to_repository_analysis_results = False
        

    @property
    def name(self) -> str:
        return self.__class__.task_enum.value

    def get_total_outputs(self):
        return sum([self._has_sent_to_repository_analysis_results])
    
    def setRepositoryAnalysisResults(self, repositoryAnalysisResults):
        self.repositoryAnalysisResults = repositoryAnalysisResults
    
    def getRepositoryAnalysisResults(self):
        return self.repositoryAnalysisResults
    
    def sendToRepositoryAnalysisResults(self, pythonRepositoryAnalysisResult):
        pythonRepositoryAnalysisResult.setCacheable(self.cacheable)
        self.getRepositoryAnalysisResults().send(pythonRepositoryAnalysisResult, self.__class__.__name__)
    
    def consumeInitialRepositoryAnalysesWithNotifications(self, javaRepositoryAnalysisResult):
        self._has_sent_to_repository_analysis_results = False
        
        try:
            def consumer():
                self.workflow.set_task_in_progress(self, javaRepositoryAnalysisResult.getId())
                self.consumeInitialRepositoryAnalyses(javaRepositoryAnalysisResult)
                
                repository_analysis_results_conf = PythonRepositoryAnalysisResult()
                repository_analysis_results_conf.setCorrelationId(javaRepositoryAnalysisResult.getId())
                repository_analysis_results_conf.setIsTransactionSuccessMessage(True)
                repository_analysis_results_conf.totalOutputs = self.get_total_outputs()
                if self._has_sent_to_repository_analysis_results:
                    self.sendToRepositoryAnalysisResults(repository_analysis_results_conf)
                    
            
            timeout = int(javaRepositoryAnalysisResult.timeout) if int(javaRepositoryAnalysisResult.timeout) > 0 else int(self.timeout)
            
            if timeout > 0:
                process = multiprocessing.Process(target=consumer)
                process.start()
                process.join(timeout)
                if process.is_alive():
                    process.terminate()
                    raise TimeoutError
            else:
                consumer()
            
        except Exception as ex:
            self.workflow.local_logger.exception("")
            try:
                send_failed = True
                if ex.__class__ == TimeoutError:
                    send_failed = self.on_consume_initial_repository_analyses_timeout(javaRepositoryAnalysisResult)
                
                if send_failed:
                    javaRepositoryAnalysisResult.setFailures(int(javaRepositoryAnalysisResult.getFailures()) + 1)
                    self.workflow.failed_jobs_topic.send(FailedJob.from_exception(javaRepositoryAnalysisResult, ex, self))
            
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)
        
        finally:
            try:
                self.workflow.set_task_waiting(self)
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)
    
    def consumeInitialRepositoryAnalyses(self, javaRepositoryAnalysisResult):
        pass
    
    def on_consume_initial_repository_analyses_timeout(self, java_repository_analysis_result):
        return True
    
    def close(self):
        pass
